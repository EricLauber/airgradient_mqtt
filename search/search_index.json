{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AirGradient for Arduino using MQTT","text":"<p>This is an Arduino software implementation for the AirGradient DIY Air Quality Sensor Pro, PCB version 4.2. I have paused development for this project.</p> <p>I created this fork of AirGradient's Arduino code prior to their implementation of MQTT and local web server support. My intention was to add that functionality while also bringing in other software development best practices such as automated testing and Continuous Integration and patterns like SOLID.</p> <p>The previous base configuration for an AirGradient product is for it to log data to AirGradient's servers. This sketch augments that functionality with MQTT capabilities to log data to a server of your choice.</p> <p>With this implementation you get:</p> <ul> <li>MQTT support with the option to continue using AirGradient's data logging.</li> <li>An object-oriented implementation that tries to follow SOLID to make it easier to extend.</li> <li>Automated test coverage built with AUnit and run using EpoxyDuino to simulate the behavior of real hardware and facilitate continuous integration.</li> <li>Example implementations using GitHub Actions to Continuous Integrate and run tests based on EpoxyDuino.</li> <li>Example documentation built with MkDocs.</li> </ul>"},{"location":"goals/","title":"Goal's of this Project","text":"<p>Early on in my career I wrote Arduino sketches for some hobby applications. They were small, simple, and did the job. But debugging and testing was tedious - you had to upload the sketch to your controller ever time you wanted to make a change and test it manually.</p> <p>With the benefit of hindsight, I realize we can do more. My goal with this project is to apply several principles of modern software development to an Arduino sketch, and to gain the practice of doing them with C++. My hope is that my examples of applying these practices an ideas encourages others to grow further in their coding journey and apply some of these concepts themselves.</p>"},{"location":"goals/#modern-software-architectures-and-design-principles","title":"Modern Software Architectures and Design Principles","text":"<p>I am a fan of Clean Architecture (like this .NET implementation) and SOLID. These patterns trade adding some complexity in the design and layout of the code for flexibility and extensibilty. Object-oriented objects and single-purpose functions are easier to test and become confident in their behavior. Defining and inheriting interfaces makes it easy to swap one component for another. Although there isn't a lot of reusability within this sketch, hopefully building objects in this way demonstrates an example of what's possible on the Arduino platform, and gives others options and tools to copy and reuse.</p>"},{"location":"goals/#automated-testing","title":"Automated Testing","text":"<p>Manual testing is common for entry-level embedded systems like Arduino, but in the professional space automated testing is a much. Writing tests as code enables making sure tests run the same way, every time. They can also run much faster. Having good tests in places brings trust and safety; you know that if you make a change to one part of the software that you will be alerted if that negatively impacts something else. This project uses AUnit for its test framework.</p>"},{"location":"goals/#continuous-integration","title":"Continuous Integration","text":"<p>Going one step further from automated testing is being able to quickly integrate changes. Typically for an Arduino-based system, running tests (manually or automated) requires uploading the sketch to a real microcontroller (in AirGradient's case an ESP8266) and running the tests. EpoxyDuino is an implementation of Arduino on Linux. Being able to run Arduino code without physical Arduino hardware speeds up the development process tremendously. You can come up with a new idea, write the code and tests in minutes, and run the tests in seconds. No need to have a physical device on-hand, plug it into a computer, select the appropriate port, or to wait for the upload to complete. No need to repeat these manual steps every time you make a change.</p> <p>Manually testing on physical hardware is still important, but combining automated tests and continuous integration means the majority of the effort can be done without the hardware.</p>"},{"location":"homeassistant/","title":"Integrating with Home Assistant","text":"<p>Home Assistant is a free and open-source software for home automation that is designed to be the central control system for smart home devices with focus on local control and privacy.</p> <p>My goal behind adding MQTT to the AirGradient was to integrate with Home Assistant and use HA as an MQTT Broker. Follow these instructions to configure Home Assistant in this way.</p>"},{"location":"homeassistant/#general-ha-setup","title":"General HA setup","text":"<ol> <li>Create a user for mqtt.</li> <li>Setup the broker. Configure it for the user.</li> <li>Point the publisher or subscriber to the broker (in our case the AirGradient is an MQTT publisher). Has to be able to call mqtt:// instead of http:// and access the port.<ol> <li>If you have custom firewall or routing rules in place, you may run into some challenges. I wasn't able to use DNS and nginx Proxy Manager to provide a friendly hostname for AirGradient to use, and instead had to use Home Assistant's IP address in order to establish a connection.</li> </ol> </li> <li>Add sensors to the yaml in home assistant to receive and parse the data based on the MQTT topic.</li> <li>Update the UI to visualize the data.</li> </ol>"},{"location":"homeassistant/#creating-sensors-within-home-assistant","title":"Creating sensors within Home Assistant","text":"<p>I created the following sensors in <code>configuration.yaml</code> while using the topic <code>home/roomname</code>. You'll need to modify the code to match your intended topic.</p> <pre><code># Air Gradient sensors\nmqtt:\n  - sensor:\n      name: \"Room-name Temperature\"\n      state_topic: \"home/roomname/temperature\"\n      unit_of_measurement: \"\u00b0F\"\n  - sensor:\n      name: \"Room-name Humidity\"\n      state_topic: \"home/roomname/humidity\"\n      unit_of_measurement: \"%\"\n  - sensor:\n      name: \"Room-name NOX Index\"\n      state_topic: \"home/roomname/nox_index\"\n  - sensor:\n      name: \"Room-name TVOC Index\"\n      state_topic: \"home/roomname/tvoc_index\"\n  - sensor:\n      name: \"Room-name PM 1\"\n      state_topic: \"home/roomname/pm01\"\n      unit_of_measurement: \"\u00b5g/m3\"\n  - sensor:\n      name: \"Room-name PM 2.5\"\n      state_topic: \"home/roomname/pm25\"\n      unit_of_measurement: \"\u00b5g/m3\"\n  - sensor:\n      name: \"Room-name AQI\"\n      state_topic: \"home/roomname/pm25AQI\"\n  - sensor:\n      name: \"Room-name PM 0.3\"\n      state_topic: \"home/roomname/pm03\"\n      unit_of_measurement: \"\u00b5g/m3\"\n  - sensor:\n      name: \"Room-name PM 10\"\n      state_topic: \"home/roomname/pm10\"\n      unit_of_measurement: \"\u00b5g/m3\"\n  - sensor:\n      name: \"Room-name CO2\"\n      state_topic: \"home/roomname/co2\"\n      unit_of_measurement: \"ppm\"\n</code></pre>"},{"location":"homeassistant/#visualization","title":"Visualization","text":"<p>Here are two sample visualizations I build for Home Assistant.</p>"},{"location":"homeassistant/#aqi-gauge-card","title":"AQI Gauge Card","text":"<pre><code>type: gauge\nentity: sensor.room-name_aqi\nname: Air Quality Index\nneedle: true\nmin: 0\nmax: 250\nsegments:\n  - from: 0\n    color: '#43a047'\n  - from: 51\n    color: '#ffa600'\n  - from: 101\n    color: '#f68f1e'\n  - from: 151\n    color: '#ed1c25'\n  - from: 201\n    color: '#a2064a'\n</code></pre>"},{"location":"homeassistant/#metrics-list","title":"Metrics List","text":"<pre><code>type: entities\nentities:\n  - entity: sensor.room-name_temperature\n    name: Temperature\n  - entity: sensor.room-name_humidity\n    name: Humidity\n  - entity: sensor.room-name_co2\n    name: CO2\n  - entity: sensor.room-name_pm_0_3\n    name: PM 0.3\n  - entity: sensor.room-name_pm_1\n    name: PM 1\n  - entity: sensor.room-name_pm_2_5\n    name: PM 2.5\n  - entity: sensor.room-name_pm_10\n    name: PM 10\n  - entity: sensor.room-name_aqi\n    name: Air Quality Index\n  - entity: sensor.room-name_nox_index\n    name: NOX Index\n  - entity: sensor.room-name_tvoc_index\n    name: TVOC Index\ntitle: room-name Air Quality\n</code></pre>"},{"location":"intro/","title":"What is AirGradient?","text":"<p>AirGradient is a company that designs, builds, and sells air quality sensors that are are open-source and open-hardware. The electronic schematics for the PCB, the firmware code, and the CAD files for the case are free and available. Their products are repair-friendly, do not require any subscription (unless you want to use their service), and can be entirely self-hosted. AirGradient has more info about who they are here, and have a manifesto written here.</p>"},{"location":"intro/#the-air-quality-monitors","title":"The Air Quality Monitors","text":"<p>If you want to buy completely build or partially-built products, AirGradient offers a variety of indoor and outdoor air quality sensors. They come with different sensors, and many versions can be upgraded later by buying and installing sensors later. The code in this repo targets the AirGradient Pro v2.4, and you're free to upgrade an AirGradient's functionality and tweak it how you see fit. If you decide to purchase a different AirGradient product, you can modify this code to meet that goal.</p>"},{"location":"references/","title":"References","text":"<p>AirGradient provides several resources for DIY support and customization.</p> <ul> <li>DIY Pro 4.2 build instructions</li> <li>DIY Pro Presoldered 4.2 build instructions</li> <li>AirGradient PCB and 3D Printer files</li> <li>AirGradient Example 4.2 sketch</li> </ul>"},{"location":"references/#others","title":"Others","text":"<p>There are several forks of the original AirGradient arduino repo that add alternative capabilities that I used for reference.</p> <ul> <li>JHadley1406 / aigradient_arduino</li> <li>hjburke / airgradient-mqtt</li> <li>nsbk / airgradient_mqtt</li> <li>agileek / AirGradientHomeAssistant</li> <li>geerlingguy / airgradient-prometheus</li> <li>Jeff Geerling - Monitoring my home's air quaity (CO2, PM2.5, Temp/Humidity) with AirGradient's DIY sensor</li> </ul>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#flashing-this-firmware-to-your-airgradient","title":"Flashing this firmware to your AirGradient","text":"<ol> <li>Setup your environment by downloading and installing one or more of the following options:<ol> <li>Arduino IDE</li> <li>Arduino CLI</li> <li>VS Code with the Arduino extension to your system.</li> </ol> </li> <li>Clone this repo or download the latest release (a zip of the source code).</li> <li>Open <code>airgradient_mqtt.ino</code> with your chosen Arduino tools.</li> <li>Install all required Arduino reference libraries.</li> <li>Plug in the microcontroller for your AirGradient (such as an ESP8266 Wemos LOLIN D1 mini) and upload the sketch to the controller.</li> </ol>"},{"location":"setup/#automated-tests","title":"Automated Tests","text":"<p>This project leverages AUnit to facilitate building automated tests and EpoxyDuino to mock an Arduino on a PC and run continuous integration.</p>"},{"location":"setup/#setting-up-your-environment","title":"Setting up your environment","text":"<p>I ran tests using Windows Subsystem for Linux (WSL). Follow these steps to get started - you may be able to skip several steps on a standard Linux distro or macOS.</p> <p></p> <ol> <li>Install the AUnit library within the Arduino environment of your choice.</li> <li>Setup and configure WSL.<ol> <li>At the time of this running, the provided Ubuntu distro requires an <code>apt update</code> before proceeding.</li> <li>EpoxyDuino requires a C++ compiler and make. Add them to your install with <code>apt install g++</code> and <code>apt install make</code>.</li> </ol> </li> <li>Clone the EpoxyDuino repo and place it within the <code>user/Documents/Arduino/libraries</code> folder (this is not a required location, but this project is setup assuming EpoxyDuino is located here).</li> <li>Add a <code>.env</code> file to the root of this project with the following format:</li> </ol> <pre><code>arduino_ide_dir=LOCATION_OF_ARDUINO_IDE\n</code></pre>"},{"location":"setup/#running-tests","title":"Running tests","text":"<p>You are now ready to build and compile and run the tests. Follow these instructions to run all tests from the root of this project. I prefer to use the WSL terminal within VS Code for this purpose.</p> <pre><code>$ make -C tests clean\n\n$ make -C tests tests\n$ make -C tests runtests | grep failed\n</code></pre> <p>Alternatively, you can browse to the subfolder containing a specific subset of tests and run those directly.</p> <pre><code>$ make clean\n\n$ make\n$ make run\n</code></pre>"},{"location":"implementation/","title":"Implementation Details","text":"<p>Todo</p> <ul> <li>Talk about domain objects</li> <li>interfaces and DI</li> <li>switchboard file and the few global variables</li> <li>how to update or replace components</li> </ul>"},{"location":"implementation/configstatemachine/","title":"Startup Config State Machine","text":"<p>Typically when the AirGradient is powered on it will cycle through a few general steps:</p> <ul> <li>Warming up the sensors</li> <li>Connecting to a saved WiFi Access Point or hosting its own AP for config purposes</li> <li>Beginning operation</li> </ul> <p>If the user holds the push button on the back of the AirGradient while powering it on, it will enter the Config State Machine. A short press (essentially a click) will cycle through the options. A long press (greater than 4 seconds) will select the current option. The display on the front of the AirGradient will indicate which state it is currently in.</p>"},{"location":"implementation/configstatemachine/#select-an-option","title":"Select an Option","text":"<p>These are the initial states that the AirGradient will run through:</p> <pre><code>stateDiagram\n    direction LR\n\n    SelectState: Select State\n    EditConfigState: Edit Display Config State\n    ClearState: Clear Config and WiFi Data State\n    RebootState: Reboot State\n\n    [*] --&gt; SelectState\n    SelectState --&gt; EditConfigState\n    EditConfigState --&gt; ClearState\n    ClearState --&gt; RebootState\n    RebootState --&gt; SelectState</code></pre> State Description Select State This state lets the user know they are in the Config State Machine and that they should cycle through and select an option. Edit Display Config State Long-pressing this state will enter the Display Config flow - see the section below for details. Clear Config and WiFi Data State Long-pressing this state will clear the local storage, erasing the saved Display Config State, WiFi configuration, and MQTT configuration. Reboot State Long-pressing this state will restart the AirGradient equivalent to disconnecting and reconnecting the power. User should choose this to exit the flow."},{"location":"implementation/configstatemachine/#edit-the-display-configuration","title":"Edit the Display Configuration","text":"<p>If users long-press the Edit Display Config State they will enter this flow. The user may select what the Display should show during regular operation. Short-pressing will cycle through each option. Long-pressing on an option will save that to the local storage, and return the user to the Select State from the previous flow.</p> <pre><code>stateDiagram\n    direction LR\n\n    DisplayConfigTempC\u03bcgm3: Celsius and \u03bcgm3\n    DisplayConfigTempF\u03bcgm3: Fahrenheit and \u03bcgm3\n    DisplayConfigTempCAQI: Celsius and US AQI\n    DisplayConfigTempFAQI: Fahrenheit and US AQI\n\n    [*] --&gt; DisplayConfigTempC\u03bcgm3\n    DisplayConfigTempC\u03bcgm3 --&gt; DisplayConfigTempF\u03bcgm3\n    DisplayConfigTempF\u03bcgm3 --&gt; DisplayConfigTempCAQI\n    DisplayConfigTempCAQI --&gt; DisplayConfigTempFAQI\n    DisplayConfigTempFAQI --&gt; DisplayConfigTempC\u03bcgm3</code></pre>"},{"location":"implementation/networking/","title":"Networking","text":"<p>Todo: </p> <ul> <li>networking dependency injection</li> <li>MQTT</li> <li>HTTP Verbs</li> </ul>"},{"location":"implementation/rtti/","title":"Run-Time Type Information","text":"<p>For this sketch I tried to implement and apply Object Oriented Programming techniques were it made sense. I had thought I might reuse the State Machine concept, and built <code>MachineBase</code> and <code>StateBase</code> to be extendable.</p> <p>The different <code>ConfigStateMachine</code> states like <code>ClearState</code> implement <code>StateBase</code> and its references to <code>MachineBase</code>, but require awareness of the <code>ConfigStateMachine</code> in order to write to the OLED display. To do this, <code>ClearState</code> requires Run-Time Type Information (RTTI) so that it can <code>dynamic_cast&lt;&gt;</code> a <code>MachineBase</code> to <code>ConfigStateMachine</code>.</p> <p>Many embedded systems do not support RTTI, and for this reason the Arduino compiler disables it by default. An ESP8266 can support RTTI, but to provide Arduino support, the ESP Arduino core implementation avoids its use and implements <code>TypeConversionFunctions</code> combined with Enums. Applied to our case, <code>MachineBase</code> gets a <code>MachineType</code> Enum. Other objects and classes can read the Enum and determine what type the <code>MachineBase</code> implementation it is.</p> <p>I prefer use of <code>dynamic_cast&lt;&gt;</code> because I feel it helps satisfy SOLID. TODO - finish this statement.</p> <p>This sketch includes both an implementation that avoids use of RTTI and one that leverages it. TODO - get the <code>#if</code> directives working properly to easily switch.</p> <p>A file called <code>platform.txt</code> contains the compiler flags for a particular board. On Windows I found mine at this path: <code>C:\\Users\\USERNAME\\AppData\\Local\\Arduino15\\packages\\esp8266\\hardware\\esp8266\\3.1.2\\platform.txt</code>.</p> <p>I replaced the original line:</p> <pre><code>compiler.cpp.flags=-c \"{compiler.warning_flags}-cppflags\" {build.stacksmash_flags} -Os -g -free -fipa-pta -Werror=return-type -mlongcalls -mtext-section-literals -fno-rtti -falign-functions=4 {build.stdcpp_level} -MMD -ffunction-sections -fdata-sections {build.exception_flags} {build.sslflags} {build.mmuflags} {build.non32xferflags}\n</code></pre> <p>With this alternative that swapps the <code>fno-rtti</code> flag for <code>-frtti</code>:</p> <pre><code>compiler.cpp.flags=-c \"{compiler.warning_flags}-cppflags\" {build.stacksmash_flags} -Os -g -free -fipa-pta -Werror=return-type -mlongcalls -mtext-section-literals -frtti -falign-functions=4 {build.stdcpp_level} -MMD -ffunction-sections -fdata-sections {build.exception_flags} {build.sslflags} {build.mmuflags} {build.non32xferflags}\n</code></pre> <p>This enables RTTI with the ESP8266 and facilitates using <code>dynamic_cast&lt;&gt;</code>.</p>"}]}